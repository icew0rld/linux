# 文件

## 文件是什么？

文件也是一种抽象。由操作系统提供的抽象。抽象了磁盘。



## 文件包含哪些东西？

名字

数据：一个字节序列

### 打开的文件数据结构

![](/Users/acer/project/linux/doc/pic/pic%203.png)



fd标志目前只有：close_on_exec，默认是关闭的，如果打开，则exec时，文件描述符会被关闭。

linux上没有vnode，而是使用了inode，但概念上是一样的。

文件状态标志包含什么：open的oflag和fcntl可以设置的除close_on_exec外的

inode包含什么：包含文件的大部分元信息和磁盘块编号地址，比如下文的stat数据大部分来自inode，只有文件名和inode编号来自目录项。

### stat结构体

![](/Users/acer/project/linux/doc/pic/pic 4.png)

st_mode

​	类型

​	设置uid和设置gid

​	访问权限位

类型

- 普通文件
  - 文本文件：由多行组成
  - 二进制文件

- 目录文件：管理文件系统结构的系统文件

- 字符特殊文件：和IO设备有关

- 块特殊文件：和IO设备有关

- 管道

- socket

- 符号链接

## 进程中可对文件执行哪些操作？

### 系统调用：不带用户空间缓冲区的IO

操作系统提供的系统调用，通常称为不带缓冲区的IO，因为它没有在用户空间设有缓冲区。（**注意：不是指内核中没有缓冲区**）。

文件描述符：打开的文件的引用

#### 打开、关闭

open:

- 内核要创建一些东西、做一些工作
- oflag参数影响后续对文件的操作的行为：
  - 读写
  - 追加
  - 测试文件不存在创建
  - 访问权限位
  - exec时关闭文件
  - 不follow符号链接
  - 非阻塞io
  - 同步
  - 截断

close：

- 内核要清理一些东西
  - 释放记录锁等。
  - 进程终止，内核自动关闭它打开的文件。

#### 读写

lseek:

- lseek大于文件长度，下一次写会导致文件中构成一个空洞，空洞会被读为0，空洞不要求在磁盘上占空间。

read：

- 默认为阻塞io
- read ahead

write：

- 默认为阻塞io

- delayed write：当我们向内文件写入数据使，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再写入磁盘。这叫延迟写。**所以write返回，不能等同于已经写入磁盘。要保证写入磁盘，要用下文的同步机制**



#### 打开同一个文件时的行为

- 共享同一个inode，独立的文件描述符、文件表项
- write：偏移量改变，当前文件长度可能改变
- O_APPEND：每次write，偏移量会被设置为当前文件大小
- lseek：只改变偏移量



#### 复制文件描述符

- 共享共一个inode、文件表项，独立的文件描述
- dup/dup2：复制一个现有的文件描述符



#### 可以有哪些原子操作

- open+O_APPEND：以O_APPEND打开的文件，每次写之前，内核都会将当前偏移量设置到文件的末端。

- pread, pwrite：定位+读原子操作，定位+写原子操作

- open+O_CREAT|OEXCL：检测文件+创建文件原子操作，不存在才创建，存在出错



#### 同步

sync：将修改过的缓冲区块，排入队列。然后返回，不等待实际写磁盘操作结束。

fsync：等待实际写磁盘结束才返回。

fdatasync：和fsync类似，只影响文件的数据部分，不更新文件属性。



#### 属性控制

fcntl：改变打开文件的属性。

- 复制描述符
- 获取/设置文件描述符标志
- 获取/设置文件状态标志
- 获取/设置异步IO所有权
- 获取/设置记录锁



#### 其他系统调用

stat：获取文件的属性信息（stat struct）

access：按进程实际uid和实际gid进行访问权限测试

unmask：设置进程的文件模式创建屏蔽字

chmod：更改文件的访问权限

chown：改变文件uid、gid

truncate: 截断文件

futimens、utimensat、utimes：改文件时间



#### 目录

link：创建一个指向现有文件的链接

unlink：删除目录项

remove：解除对一个文件或目录的链接

rename：重命名文件或目录

symlink：创建符号链接

readlink：读符号链接

mkdir：创建目录

rmdir：删除目录

读目录函数

chdir：改变进程的当前工作目录



### C标准IO库：带用户空间缓冲区

#### 流

流的定向：宽定向、字节定向

fwide：设置流的定向

#### FILE对象

包含文件描述符、缓冲区、出错标志、文件结束标志

#### 缓冲

目的是尽量减少使用read和write系统调用的次数

缓冲的类型：

​	全缓冲：填满标准IO缓冲后才进行实际IO操作，常用malloc分配，用fflush将缓冲写到内核

​	行缓冲：在输入输出中遇到换行，标准IO库执行IO操作

​	不带缓冲：标准IO库不对字符进行缓冲存储。

setbuf：更改流的缓冲类型

fflush：将流所有未写的数据都被传送到内核

#### 打开、关闭

fopen：打开流，type和系统调用open的flag有一定的映像关系，终端设备默认是行缓冲，其他设备默认是全缓冲

fclose：关闭流，冲洗缓冲区中的输出数据，丢弃其中的输入数据，如果标准IO已经为流自动分配一个缓冲区，则释放此缓冲区。进程正常终止，所有流都被冲洗和关闭。

#### 每次一个字符IO

- fgetc

- fputc

#### 每次一行

- fgets

- fputs

#### 二进制IO

- fread

- fwrite

#### 定位流

- ftell/fseek

- fgetpos/fsetpos

#### 格式化IO

- fprintf

- fscanf

#### 创建临时文件

- tmpnam

- tmpfile

- fmemopen：创建标准内存流，没有文件，所有IO都是通过在缓冲和主存之间来回传送字节来完成的。

### 对文件使用记录锁@todo



## 什么是目录？

目录也是一种文件，用来记录文件的位置。



## 什么是文件系统？

操作系统处理文件的部分就叫文件系统。



## 文件系统是怎么实现的？ @todo

ext4为例

mbr：Master Boot  Record, 主引导记录，磁盘的0号扇区，引导计算机

分区表

磁盘分区

BIOS

引导块：分区的第一块，其中的程序将装载该分区的操作系统

inode：index-node，保存每个文件包含哪些磁盘块地址的数据结构

目录：

​	一个目录文件由一组目录项组成

​	每个目录项包含文件名和指向文件inode的指针

​	目录文件要考虑文件名长度不同如何布局的问题

​	还要考虑查询效率的问题，顺序查找，还是用散列表之类的快速查找数据结构

hard-link：另外一个目录项也指向inode

symbolic-link: 另外一个目录项指向一个文件（类型为LINK类型），这个文件包含另一个文件的文件名。操作系统发现读到的是一个LINK类型的文件时，就会再去读这个文件中的文件名所对应的文件

块大小：大了空间利用率低，读写速度快；小了反之。Linux ext4块大小是4KB

空闲块怎么记录：磁盘块链表或位图

一致性：fsck程序

打开文件的内核数据结构



## 虚拟文件系统是什么？@todo

vnode是什么：把与文件系统无关的inode部分叫做vnode。Linux没有vnode，而是采用了一个与文件系统相关的inode和一个与文件系统无关的inode。



## 相关命令

sudo tune2fs -l /dev/mapper/vagrant--vg-root

