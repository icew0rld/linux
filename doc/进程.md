# 进程

## 进程是什么？

进程是对正在运行的程序的一个抽象。

## 进程包含哪些东西？

- 地址空间
  - 命令行参数

  - 环境表

  - 栈

  - 堆

  - 数据段

  - 代码段

  - 其他：共享库、文件内存映射

  - 内核地址空间

    ![](/Users/acer/project/linux/doc/pic/pic 2.png)

- cpu
  - pc
  - 寄存器
- 内核数据结构
  - 进程表项

    - 打开的文件的文件描述符列表

      ![](/Users/acer/project/linux/doc/pic/pic 1.png)

    - **（以下项不确定是否放在进程表项中，但一定是进程的属性，其中加粗是子进程不继承的）**

    - id相关：实际用户id，实际组id，有效用户id，有效组id，附属组id，进程组id，会话id，设置用户id标志，设置组id标志，**进程id，父进程id**

    - 控制终端

    - 当前工作目录

    - 根目录

    - 文件模式创建屏蔽字

    - **文件锁**

    - 信号屏蔽和安排

    - 环境

    - 资源限制

    - **时间相关**

    - **未处理闹钟**

    - **未处理信号集**

    - 状态

## 如何创建进程？

已存在的进程执行fork系统调用创建新进程。

（操作系统初始化时会创建一些进程，所以不用担心第一进程怎么来的。）

### fork

fork系统调用创建新进程。

- 调用一次，返回两次。
- **独立的地址空间**：子进程复制父进程的地址空间。逻辑上，子进程的地址空间和父进程是不相关的。只是由于代码段是只读的，父子进程地址空间的代码段映射到同一个物理页面以共享是合理的。另外，如果使用Copy-On-Write技术，如果没有写，其他段也可能映射到相同的物理页面。
- **复制打开的文件描述符**。
- 其他继承与没有继承的进程属性，见上一节『进程包含哪些东西』。

### execve

execve执行另一个程序。

- 用磁盘上的一个新程序，创建新进程地址空间。

- 6个exec*函数，其中execve是系统调用，其他是在其基础上的库函数。

## 如何终止进程？

进程有8种终止方式：

正常终止：

- 从main返回
- 调用exit
- 调用\_exit或\_Exit
- 最后一个线程从其启动例程返回 
- 从最后一个线程调用pthread_exit

异常终止：

- 调用abort
- 接收到一个信号
- 最后一个线程对取消做出反应



从main返回等价于调用exit。



exit会调用atexit注册的**终止处理程序**，对所有打开的文件调用fclose，最后调用\_exit或\_Exit退出。fclose会把缓冲区数据flush到磁盘，和关闭打开的文件描述符不是等同的。



_exit或\_Exit直接退出。（是否对打开的文件调用fclose由实现决定，UNIX中没有fclose）



以上三者都会返回**终止状态**，是一个int。



调用abort产生SIGABRT信号，是接受到信号的一个特例。



接受到信号，进程可以在信号处理函数中处理、忽略信号或退出。@todo 退出时做些什么工作



**资源释放**

退出时资源释放一定会发生。

以上8种情况，最终都会执行内核同一段代码，关闭所有打开的描述符、释放它使用的存储器等。



**子进程终止**

- 发信号SIGCHLD给父进程：父进程可以注册一个信号处理函数来处理，默认动作是忽略。
- 内核维护一段信息保存子进程退出时的信息
  - 父进程可用wait获得这段信息，之后内存释放它
  - 如果父进程比子进程先终止，子进程的父进程会被内核改为init，init会在子进程退出时wait之
  - 如果父进程一直运行，且没有wait子进程，子进程的信息会一直存在在内核，这种状态叫做僵死状态



## 进程能做什么？

概括来说，进程可以从输入获取数据到内存，执行cpu的指令以对数据进行运算后，把数据输出到输出设备。

### 在进程中执行CPU指令

- 读写内存
- 算数运算
- 逻辑运算
- 控制
- 函数
  - 调用操作系统提供的系统调用

### 在进程中使用内存

- 使用栈空间
  - 函数调用
  - 局部变量
  - 命令行参数（不确定是否是在栈顶@todo）
  - 环境变量（不确定是否是在栈顶@todo）
- 使用堆空间
  - malloc、free等c语言库函数
  - sbrk系统调用
- 其他空间
  - data段：全局变量
  - 共享库内存映射区
  - 文件映射 @todo
  - IO端口空间 @todo
  - 内核空间 @todo

### 在进程中进行IO

- 磁盘IO：读写磁盘，一般而言，操作系统用文件系统管理磁盘上的数据，将其抽象为文件和目录。进程可以通过系统调用操作文件和目录。详见：[文件](文件.md)

- 网络IO
- 终端IO

### 其他能力

- 信号：发送、接收、处理信号。详见：[信号](信号.md)

- 子进程：创建子进程，等待子进程结束并获取其状态。

- 线程



## 进程会处于哪些状态？

运行

就绪

阻塞

- 在等待io，变成阻塞状态
- sleep系统调用会导致进程进如阻塞状态，直到另一个进程用wakeup系统调用将其唤醒或sleep时间到。

### 忙等待是什么？

在一个循环中不断执行某项操作，cpu不是处于阻塞状态，即忙等待会浪费cpu时间。



## 一台计算机上有多个进程怎么运行？

CPU快速切换。进程竞争的资源是CPU。操作系统的进程调度器进行进程调度。

### 怎么调度？

基于调度优先级的粗粒度控制，进程可通过调整nice选择以更低的优先级运行



## 进程间怎么相互通信和协作？

### 数据传递

- 文件：打开同一个文件
- pipe：单向，同一祖先的进程间
- named pipe：即fifo，单向，不限是否是同一祖先的进程间
- 消息队列：双向，不限是否是同一祖先的进程间，是一个消息链表。（有不好的地方不考虑再使用）
- 共享存储：共享一个给定的存储区域，快，存储区一般被映射到进程地址空间栈之下，和文件内存映射mmap不是同一个东西，前者没有文件。
- unix domain socket: 同机器，双向，比socket高效，因为只复制数据
- socket：不同机器

### 同步

- 记录锁：记录在这里指文件中的一个区域
- 信号量：是一个计数器，要用也用POSIX的，最好用记录锁
- 互斥量：可视为只有2个值的信号量，Linux一般在线程同步中使用pthread_mutex_t互斥量，但这个也支持进程间同步使用（方法是将互斥量放到共享内存中）@todo 待验证

### 其他

- 信号

### pipe

是什么：

- 内核提供的一种进程间数据传递机制
- 单向
- 同一祖先的进程间

包括什么：

- 两个文件描述符：一个输入、一个输出
- 内核中维护的管道抽象所需的东西
  - 缓冲区

支持哪些操作：

- 创建：pipe系统调用
- 读写：像读写文件那样读写管道的文件描述符

要点：

- 由于管道通过文件描述符读写，而文件描述符只有父子进程才能共享，因此只能用在同一个祖先的进程间。

### named pipe

是什么：

- 内核提供的一种进程间数据传递机制
- 单向
- **可以不是同一祖先的进程间**
- 是一种文件

包括什么：

- 在文件系统中的名字、文件
- 内核数据结构

支持哪些操作：

- 创建：mkfifo
- 打开/关闭/读/写/删除：和文件一样

### 共享存储

是什么：

- 内核提供的一种进程间数据传递机制
- 是两个进程共享的存储区
- **双向**
- 可以不是同一祖先的进程间

包含什么：

- 内核数据结构shmid_ds结构体
- key：不同进程用这个key来找到同一个共享存储，key_t类型，实现为长整型
- 共享存储id
- 一些限制：最大字节长度、最大段数

支持哪些操作：

- shmget：创建或引用共享存储
- shmctl：
  - 读shmid_ds
  - 设置shmid_ds中的某些字段
  - 删除共享存储
  - 加解锁（linux中有）
- shmat：将共享存储连接到地址空间
- shmdt：解除连接
- 读写：对连接后的地址空间的读写。内存操作，不阻塞。

### socket

是什么：

- 内核提供的一种进程间数据传递机制
- 进程可位于同一台计算机上，也可位于不同计算机上
- socket是通信端点的抽象
- 双向

包含什么：

- socket描述符

支持哪些操作：

- **创建：socket**
- 关闭端：关闭读端、写端或读写端，shutdown
- **关闭socket：close**
- 转换处理器字节序和网络字节序：Linux默认是小端，TCP/IP默认是大端
- 转换二进制地址格式和十进制地址格式的
- 查询地址
- **关联地址和套接字：bind**
- **监听：listen**
- **获得连接：accept**
- **建立连接：connect**
- 读写**
  - write/read
  - send
  - sendto：带目标地址
  - sendmsg：mgshdr结构来指定多重缓冲区传输数据
  - recv
  - recvfrom
  - recvmsg
- 设置和查询socket选项
- socket中的非阻塞IO @todo
- socket中的IO多路转接 @todo
- socket中的异步IO：基于信号 @todo

### unix domain socket

是什么：

- 内核提供的一种进程间数据传递机制
- 同一台机器
- 双向

包含什么：

- pathname：绑定的文件，S_IFSOCK类型的文件
- 内核socket数据结构
- socket描述符

支持哪些操作：

- socketpair：创建由2个socket连接起来的文件描述符，两者都可读写
- socket、bind、listen、accept、connect、send、recv等和socket的接口一样
- 可以通过sendmsg和recvmsg的控制信息传递文件描述符

### 记录锁

是什么：文件中的区域作为共享数据的锁

包含什么：

- 文件

- 锁类型
- 锁区域
- vnode中锁指针，指向一个锁链表，链表元素包含锁区域、所属进程id等。

支持哪些操作

- fcntl：
  - cmd: F_GETLK测试锁,F_SETLK加锁或解锁,F_SETLKW加解锁阻塞版
- fork子进程不继承锁，exec后如果没有close_on_exec则继承锁
- 关闭任何一个fd，都会释放这个进程对应的锁

### 信号量(semaphore)

是什么：一个计数器

包含什么：

- 值
- 名字
- 内核中的数据结构

有哪些操作：

- 创建或引用
  - sem_open
  - sem_init创建未命名信号量，对应sem_destroy销毁之
- P操作：测试，如果大于0，减一，如果等于0，阻塞
  - sem_wait/sem_trywait/sem_timewait
- V操作：增加，如果等于0且有其他进程阻塞，唤起其他进程，否则，加1
  - sem_post
- 关闭:sem_close
- 删除:sem_unlink，最后一个打开的引用关闭后才删除
- 查值：sem_getvalue

## 线程

### 线程是什么？

### 为什么要用线程？

简化异步事件代码

共享地址空间和文件描述符

提高吞吐量

改善响应时间

### 线程包含什么？

- 独立的：
  - 地址空间
    - 栈（对其他线程不设防）
  - cpu
    - pc
    - 栈指针
    - 条件码
    - 通用目的寄存器
  - 内核数据结构
    - 线程id
    - 调度优先级和策略
    - 信号屏蔽字
    - errno变量
    - 私有数据：有哪些？
    - 属性：有哪些？
    - 限制？
- 共享的
  - 进程地址空间
    - 代码段
    - 数据段
    - 堆
    - 共享库
    - 数据区域
    - 栈？
  - 内核数据结构
    - 文件描述符

### 进程有哪些操作？

- 创建
  - pthread_create
    - 继承浮点环境、信号屏蔽字
- 终止
  - 终止方式：
    - 从函数返回
    - 被同一进程的其他线程取消:pthread_cancel
    - 调用pthread_exit
  - 等待终止
    - pthread_join
  - 注册清理处理程序
    - pthread_cleanup_push：取消和pthread_exit时调用，返回不调用
- 与信号交互
- 重入？

### 多线程如何通讯和协作？

- 数据传递
  - 通过共享的地址空间：数据段、堆等
- 同步
  - 互斥量
  - 读写锁
  - 条件变量
  - 屏障

### 线程如何实现？



线程中有哪些特有的问题？

进程中的东西，哪些东西是线程私有，哪些是共享？

线程创建、状态、能力、终止、通信、同步和进程不同的地方



## 如何让进程变成守护进程？

是什么：停留在后台的进程叫守护进程。



## 相关命令有哪些？

ps：列出进程

size：报告正文段、数据段、bss段的长度



## 有用的资源

进程间传递文件描述符

https://pureage.info/2015/03/19/passing-file-descriptors.html













